---
layout: post
title: ë°±ì¤€ 17135:ìºìŠ¬ ë””íœìŠ¤
date: 2020-12-01 14:12:00
author: 'SeWonKim'
categories: [CS, Algorithm]
tags: [ì•Œê³ ë¦¬ì¦˜, BOJ, êµ¬í˜„]
comments: true
description: Baekjoon 17135
---

> > [Baekjoon 17135](https://www.acmicpc.net/problem/17135)

![image](https://user-images.githubusercontent.com/30452963/100811406-edcb1d80-347d-11eb-8e7b-bc66aa04cf3c.png)

## Idea

### ë³€ìˆ˜

- int N: ê²©ìíŒì˜ ê°€ë¡œ
- int M: ê²©ìíŒì˜ ì„¸ë¡œ
- int[N][M] map: ê²©ìíŒ (0:ë¹ˆ ì¹¸, 1: ì )

- int D: ê³µê²©ì œí•œ ê±°ë¦¬
- int answer: ê¶ìˆ˜ê°€ ì œê±°í•  ìˆ˜ ìˆëŠ” ì ì˜ ìµœëŒ€ ìˆ˜

- int[M] castle: ì„± (ê°’ì´ 1ì¸ ê³³ì€ ê¶ìˆ˜ê°€ ìˆëŠ” ê³³)
- int count: ê° ì¡°í•©ë§ˆë‹¤ ê¶ìˆ˜ì˜ ê³µê²©ìœ¼ë¡œ ì œê±°í•  ìˆ˜ ìˆëŠ” ì ì˜ ìˆ˜

### ê³„ì‚°

`1. ê¶ìˆ˜ ë°°ì¹˜`
- M ê°œì¤‘ 3ê°œ ìë¦¬ë°°ì¹˜í•˜ëŠ” ì¡°í•© (next permutation)
- do - while ë¬¸ìœ¼ë¡œ ëª¨ë“  ì¡°í•© ê²½ìš°ì˜ ìˆ˜ ê³„ì‚°

`2. ê³µê²© (do - while ë‚´ë¶€)`
- for(k = 0~M) 
- 2ì¤‘ forë¬¸ì„ ëŒë©° map ê°’ì´ 1ì¸ ê²½ìš° ê²€ì‚¬ (i = N-1~0, j = 0~M)
- <del>ê°€ì¥ ê°€ê¹Œìš´ ê±°ë¦¬ì— ìˆëŠ” ê°€ì¥ ì™¼ìª½ì¸ ì ì„ ê³µê²©í•˜ë¯€ë¡œ 2ì¤‘ forë¬¸ ë„ëŠ” indexì— ì£¼ì˜</del> ê°€ì¥ ê°€ê¹Œìš°ë©´ì„œ ì™¼ìª½ì— ìœ„ì¹˜í•˜ë„ë¡ ê±°ë¦¬ ê°±ì‹ 
- ì (i,j)ê³¼ ê¶ìˆ˜(N, k)ì˜ ê±°ë¦¬ê°€ D ì•ˆìª½ì— ìˆëŠ”ì§€ í™•ì¸ í›„, ë²”ìœ„ ë‚´ì— ìˆìœ¼ë©´ <del>ì  ì œê±° count++</del> ì œê±°í•  ì ì˜ ìœ„ì¹˜ ê¸°ë¡
- ê¶ìˆ˜ 3ëª…ì´ ì œê±°í•  ì  ìœ„ì¹˜ë¥¼ ë‹¤ ê¸°ë¡í–ˆìœ¼ë©´ í•œë²ˆì— map ê°±ì‹ 

`3. ì  ì´ë™ (do - while ë‚´ë¶€)`
- 2ì¤‘ forë¬¸ì„ ëŒë©° map ê°’ì´ 1ì¸ ê²½ìš° ì„±ìª½ìœ¼ë¡œ í•œ ì¹¸ ì´ë™(i+1)

`4. ê²Œì„ ì¢…ë£Œ ê²€ì‚¬ (do - while ë‚´ë¶€)`
- 2ì¤‘ forë¬¸ì„ ëŒë©° mapì— ëª¨ë“  ì¹¸ì´ 0ì¸ ê²½ìš° ì¢…ë£Œ
- ê²Œì„ ì¢…ë£Œ í›„, ì ì˜ ìµœëŒ€ìˆ˜ ê°±ì‹  


&nbsp;  
&nbsp;

## Code

### Main

```java
public class Main {

    static int N, M, D;   
    static int answer = Integer.MIN_VALUE;
    static int count;
    
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine(), " ");
        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());
        D = Integer.parseInt(st.nextToken());
        int[][] map = new int[N][M];
        int[] castle = new int[M];
            
        for (int i = 0; i < N; i++) {
            st = new StringTokenizer(br.readLine(), " ");
            for (int j = 0; j < M; j++) {
                map[i][j] = Integer.parseInt(st.nextToken());
            }
        }
            
        for (int i = 0; i < 3; i++) {
            castle[i] = 1;
        }
        Arrays.sort(castle);
            
        int[][] tmpMap = new int[N][M];
        do {
             count = 0;			
            copy(tmpMap, map);
                
            while(isPlay(tmpMap)) {
                attack(castle, tmpMap);				
                move(tmpMap);
            }
            answer = Math.max(answer, count);
        } while(nextPermutation(castle));
            
        System.out.println(answer);
    }    
}   
```

<details>
    <summary>methods</summary>
    <div markdown="1">

    ```java
        private static void attack(int[] castle, int[][] map) {
            int[][] enemy = new int[3][2];
            for (int i = 0; i < 3; i++) {
                Arrays.fill(enemy[i], -1);
            }
            int enemyIndex = 0;
            
            for (int k = 0; k < M; k++) {
                if(castle[k] == 1) {
                    int minDis = Integer.MAX_VALUE;
                    for (int i = N-1; i >= 0; i--) {
                        for (int j = 0; j < M ; j++) {
                            int dis = getDistanse(i, j, k);
                            if(map[i][j] == 1 &&  dis <= D) {
                                if(dis < minDis 
                                        || (dis == minDis && enemy[enemyIndex][1] > j)) {
                                    enemy[enemyIndex][0] = i; 	
                                    enemy[enemyIndex][1] = j;
                                    minDis = dis;
                                }
                            }
                        }
                    } // end for i
                    enemyIndex++;
                } // end if
            } // end for k
            
            for (int i = 0; i < 3; i++) {
                if(enemy[i][0] != -1 && enemy[i][1] != -1 && map[enemy[i][0]][enemy[i][1]] == 1) {
                    map[enemy[i][0]][enemy[i][1]] = 0;
                    count++;
                }
            }
        }

        private static int getDistanse(int r1, int c1, int c2) {
            return Math.abs(r1 - N) + Math.abs(c1 - c2);
        }

        private static void move(int[][] map) {
            for (int i = 0; i < M; i++) {
                for (int j = N-1; j > 0; j--) {
                    map[j][i] = map[j-1][i];
                }
                map[0][i] = 0;	// ë§¨ ìœ—ì¤„ 0ìœ¼ë¡œ ë§Œë“¤ê¸°
            }
        }
        
        private static boolean isPlay(int[][] map) {
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < M; j++) {
                    if(map[i][j] == 1)	return true;
                }
            }
            return false;
        }
        
        private static void copy(int[][] tmpMap, int[][] map) {
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < M; j++) {
                    tmpMap[i][j] = map[i][j];
                }
            }
        }

        private static boolean nextPermutation(int[] castle) {
            int i = M-1;
            while(i>0 && castle[i-1] >= castle[i])	--i;
            if(i==0)	return false;
            
            int j = M-1;
            while(castle[i-1] >= castle[j])	--j;
            swap(i-1, j, castle);
            
            int k = M-1;
            while(i<k)	swap(i++, k--, castle);
            return true;
        }

        private static void swap(int i, int j, int[] castle) {
            int tmp = castle[i];
            castle[i] = castle[j];
            castle[j] = tmp;
        }
    ```

</div>
</details>

&nbsp;  
&nbsp;

## Review

- ê³„íš ìˆ˜ë¦½ 20ë¶„
- ì½”ë“œ ì‘ì„± 40ë¶„
- ì˜ëª» ìƒê°í•œ ë¶€ë¶„ ê³ ì¹˜ê¸° (... ì—„ì²­ ì˜¤ëœì‹œê°„)ë¶„
    1. **'ê°™ì€ ì ì´ ì—¬ëŸ¬ ê¶ìˆ˜ì—ê²Œ ê³µê²©ë‹¹í•  ìˆ˜ ìˆë‹¤'** : ê¶ìˆ˜ ìœ„ì¹˜ì—ì„œ ë°”ë¡œ ì ì„ ê³µê²©í•´ë²„ë¦¬ëŠ” ê²Œ ì•„ë‹ˆë¼ ì–´ë–¤ ì ì„ ê³µê²©í•´ì•¼í• ì§€ ê¸°ë¡í•´ë‘” ë‹¤ìŒ í•œêº¼ë²ˆì— ì£½ì—¬ì•¼í•œë‹¤.
    2. **'ê±°ë¦¬ê°€ Dì´í•˜ì¸ ì  ì¤‘ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ ì  & ê·¸ëŸ° ì ì´ ì—¬ëŸ¿ì¼ ê²½ìš°ì—ëŠ” ê°€ì¥ ì™¼ìª½ì— ìˆëŠ” ì ì„ ê³µê²©'** : ì•„ë˜ ì™¼ìª½ë¶€í„° 2ì¤‘ forë¬¸ì„ ëŒì•„ì„œ í•´ê²°í•  ì¼ì´ ì•„ë‹ˆì—ˆë‹¤. => 2ì¤‘ forë¬¸ ì“¸ ê²Œ ì•„ë‹ˆë©´ ê¶ìˆ˜ ìœ„ì¹˜ì—ì„œ BFS ì‹œì‘í•˜ëŠ” ê²ƒë„ ë°©ë²•ì¤‘ì˜ í•˜ë‚˜

attack methodì—ì„œ ì—„ì²­ë‚˜ê²Œ í—¤ë§¸ë‹¤... ğŸ¤® ìš°ì›©...
í˜¹ì‹œ ì•ˆ í’€ë¦¬ëŠ” ë¶„ë“¤ì€ ë°˜ë¡€ ì°¸ê³ í•˜ì‹œê¸¸...

```
10 10 8
1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
=> 30

5 5 2
1 0 1 1 1
0 1 1 1 1
1 0 1 0 1
1 1 0 1 0
1 0 1 0 1
=> 14
```
&nbsp;  
&nbsp;
