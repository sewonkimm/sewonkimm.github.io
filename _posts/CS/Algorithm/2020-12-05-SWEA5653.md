---
layout: post
title: SW Expert Academy 5653:ì¤„ê¸°ì„¸í¬ë°°ì–‘
date: 2020-12-05 19:45:00
author: 'SeWonKim'
categories: [CS, Algorithm]
tags: [ì•Œê³ ë¦¬ì¦˜, SW Expert Academy]
comments: true
---

> [SW Expert Academy 5653](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXRJ8EKe48DFAUo&categoryId=AWXRJ8EKe48DFAUo&categoryType=CODE&&&)

## Idea

### ğŸ¥šë³€ìˆ˜

- int T : test case
- int N : ì˜ì—­ì˜ ì„¸ë¡œ
- int M : ì˜ì—­ì˜ ê°€ë¡œ
- int K : ë°°ì–‘ì‹œê°„
- int[4][2] dir : 4ë°©í–¥ íƒìƒ‰ì„ ìœ„í•œ delta { {-1,0}, {1,0}, {0,-1}, {0,1} }
- int[?] grid : ë°°ì–‘ ìš©ê¸°
- int count : ì‚´ì•„ìˆëŠ” ì¤„ê¸°ì„¸í¬ì˜ ìˆ˜

- Class Cell : ì¤„ê¸°ì„¸í¬ ì •ë³´ë¥¼ ê¸°ë¡í•œ í´ë˜ìŠ¤
  - int pos: ì¤„ê¸°ì„¸í¬ ìœ„ì¹˜
  - int X : ìƒëª…ë ¥ ìˆ˜ì¹˜
  - int activeTime : ì´ ê°’ì´ Xì™€ ë™ì¼í•´ì§ˆë•Œ ë²ˆì‹ ì‹œì‘
  - boolean dead : ì£½ì—ˆëŠ”ì§€ í‘œì‹œ
- ArrayList<Cell> cellList : ê·¸ë¦¬ë“œì˜ ì¤„ê¸°ì„¸í¬ ìƒíƒœ
- ArrayList<Cell> note : Kì‹œê°„ë§ˆë‹¤ ê¸°ë¡í•œ ë‚´ìš©

&nbsp;

ì–´ë ¤ìš´ ì ğŸ’¦

- ë°°ì–‘ ìš©ê¸°ì˜ í¬ê¸°ëŠ” ë¬´í•œ ğŸ‘‰ ë°°ì–‘ ìš©ê¸°ì˜ ë°°ì—´ì„ ì–´ë–»ê²Œ í‘œì‹œí• ê¹Œ?
- Nê³¼ Mì˜ ìµœëŒ“ê°’ì€ 50ì´ê³ , Kì˜ ìµœëŒ“ê°’ì€ 300ì´ë¯€ë¡œ ë°°ì–‘ ìš©ê¸°ì˜ í¬ê¸°ëŠ” 700\*700 ì´ë©´ ì¶©ë¶„
- í˜¹ì‹œëª¨ë¥´ë‹ˆ 750\*750ìœ¼ë¡œ ì„¤ì •í•œë‹¤.

- Nê³¼ M ìœ„ì¹˜ë¥¼ ê¸°ë°˜ìœ¼ë¡œ 2ì°¨ì›ë°°ì—´ì„ linearí•˜ê²Œ í‘œì‹œí•  ê²ƒì´ë‹¤.
- `(n+350)*N + (m+350)` ì´ ê·¸ ìœ„ì¹˜ê°€ ë  ê²ƒì´ë‹¤.

&nbsp;

### ğŸ³í’€ì´ ì „ëµ

1. ì´ˆê¸° ìƒíƒœ gridì— ì…ë ¥
   - gird ê°’ì´ 0ì´ ì•„ë‹ˆë©´ cellListì— add
2. Kì‹œê°„ë™ì•ˆ ë°°ì–‘ ì‹œì‘
   - cellListë¥¼ ëª¨ë‘ ëŒë©´ì„œ ì‹œê°„ê³¼ ë¹„êµí•´ì„œ ë²ˆì‹
   - if(Cell.X < Cell.activeTime) ì´ë©´ ë²ˆì‹ ì‹œí‚¤ê³  noteì— ê¸°ë¡ í›„, dead = true ìƒíƒœë¡œ ë³€ê²½
   - else if(dead == false) ì´ë©´ activeTime++ í•´ì„œ noteì— ê¸°ë¡
   - noteë¥¼ pos ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬
   - noteì— (posê°€ ê°™ìŒ && dead == false)ì¸ ê²½ìš°ì˜ ì„¸í¬ê°€ 2ê°œ ì´ìƒì¼ ê²½ìš° Xê°€ í° ê²ƒë§Œ ë‚¨ê¹€
   - noteì˜ ê²°ê³¼ë¥¼ gridì— ë°˜ì˜
   - cellList ê°±ì‹ . gridì˜ cell.dead == false ê²ƒë§Œ cellListì— add
3. ì‚´ì•„ìˆëŠ” ì¤„ê¸° ì„¸í¬ì˜ ê°¯ìˆ˜ ì¶œë ¥

&nbsp;

âš ï¸ ì£¼ì˜

- ë‘ ê°œ ì´ìƒì˜ ì„¸í¬ê°€ í•˜ë‚˜ì˜ ì…€ì— ë™ì‹œì— ë²ˆì‹í•˜ëŠ” ê²½ìš°, ìƒëª…ë ¥ì´ ë” í° ì„¸í¬ ë²ˆì‹ ğŸ‘‰ ì„¸í¬ ë²ˆì‹ ë•Œë§ˆë‹¤ ë°”ë¡œë°”ë¡œ gridì— ë°˜ì˜ì‹œí‚¤ë©´ ì•ˆëœë‹¤.
- ì¤„ê¸° ì„¸í¬ê°€ í™œì„± ìƒíƒœê°€ ë˜ë©´ Xì‹œê°„ ë™ì•ˆ ì‚´ì•„ìˆëŠ”ë‹¤. ğŸ‘‰ ë°”ë¡œ ì£½ì´ë©´ ì•ˆëœë‹¤.

&nbsp;  
&nbsp;

<details>
<summary>code</summary>
<div markdown="1">

```java
import java.io.*;
import java.util.*;

public class Solution {

	public static class Cell {
		int pos, X, activeTime;
		boolean dead;
		public Cell() {}
		public Cell(int pos, int x, int activeTime) {
			this.pos = pos;
			X = x;
			this.activeTime = activeTime;
			this.dead = false;
		}
	}

	static final int NUM = 750;
	static int[][] dir = { {-1,0}, {1,0}, {0,-1}, {0,1} };
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int TC = 1; TC <= T; TC++) {
			Cell[] grid = new Cell[NUM*NUM];

			StringTokenizer st = new StringTokenizer(br.readLine(), " ");
			int N = Integer.parseInt(st.nextToken());
			int M = Integer.parseInt(st.nextToken());
			int K = Integer.parseInt(st.nextToken());

			for (int i = 0; i < N; i++) {
				st = new StringTokenizer(br.readLine(), " ");
				for (int j = 0; j < M; j++) {
					int X = Integer.parseInt(st.nextToken());
					if(X > 0) {
						int pos = (i+350)*NUM + (j+350);
						grid[pos] = new Cell(pos, X, 1);
					}
				}
			}

			ArrayList<Cell> cellList = new ArrayList<Cell>();
			ArrayList<Cell> note = new ArrayList<Cell>();
			for (int time = 1; time<=K; time++) {
				updateGrid(note, grid);

				cellList.clear();
				getCellList(grid, cellList);

				note.clear();
				writeNote(cellList, note, grid);

				sort(note);
			}

			System.out.println("#"+TC+" "+ countCell(grid));
		}
	}

	private static void getCellList(Cell[] grid, ArrayList<Cell> cellList) {
		for (int i = 0; i < grid.length; i++) {
			if(grid[i] != null && !grid[i].dead) {
				cellList.add(grid[i]);
			}
		}
	}

	private static void writeNote(ArrayList<Cell> cellList, ArrayList<Cell> note, Cell[] grid) {
		for (int i = 0; i < cellList.size(); i++) {
			Cell now = cellList.get(i);

			if (now.activeTime == now.X) {
				int x = now.pos / NUM;
				int y = now.pos % NUM;
				for (int k = 0; k < 4; k++) {
					int nx = x + dir[k][0];
					int ny = y + dir[k][1];
					int npos = nx * NUM + ny;

					if (grid[npos] == null)	note.add(new Cell(npos, now.X, 0));
				}
			}

			if(now.activeTime == now.X*2) {
				grid[now.pos].dead = true;
			}

			grid[now.pos].activeTime++;
		}
	}

	private static void sort(ArrayList<Cell> note) {
		Collections.sort(note, new Comparator<Cell>() {
			@Override
			public int compare(Cell o1, Cell o2) {
				if(o1.pos == o2.pos) {
					return o1.X - o2.X;
				}
				return o1.pos - o2.pos;
			}
	    });
	}

	private static void updateGrid(ArrayList<Cell> note, Cell[] grid) {
		if(note.size() == 0)	return;

		for (int i = 0; i < note.size()-1; i++) {
			if(note.get(i).pos != note.get(i+1).pos) {
				grid[note.get(i).pos] = note.get(i);
			}
		}
		Cell last = note.get(note.size()-1);
		grid[last.pos] = last;
	}

	private static int countCell(Cell[] grid) {
		int count = 0;
		for (int i = 0; i < grid.length; i++) {
			if(grid[i] != null && !grid[i].dead)	count++;
		}
		return count;
	}
}

```

</div>
</details>

&nbsp;  
&nbsp;

## Review

ë¬¸ì œë¥¼ ê¼¼ê¼¼íˆ ì½ì§€ì•Šì•„ì„œ í…ŒìŠ¤íŠ¸ì¼€ì´ìŠ¤ 3ë²ˆì§¸ì—ì„œ ìê¾¸ 70ì´ ë‚˜ì™€ ê³ ìƒí–ˆë‹¤ ğŸ˜­ ë‚˜ë¨¸ì§€ëŠ” ê·¸ëƒ¥ êµ¬í˜„ë¬¸ì œë¼ì„œ ê´œì°®ì•˜ë‹¤.

' _ì¤„ê¸° ì„¸í¬ê°€ í™œì„± ìƒíƒœê°€ ë˜ë©´ Xì‹œê°„ ë™ì•ˆ ì‚´ì•„ìˆëŠ”ë‹¤_ 'ëŠ” ì¡°ê±´ì— ìœ ì˜í•˜ì‹œê¸¸...!

&nbsp;  
&nbsp;
