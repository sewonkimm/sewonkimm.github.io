---
layout: post
title: SW Expert Academy 1767:í”„ë¡œì„¸ì„œ ì—°ê²°í•˜ê¸°
date: 2021-03-17 16:38:00
author: 'SeWonKim'
categories: [CS, Algorithm]
tags: [ì•Œê³ ë¦¬ì¦˜, SW Expert Academy, SWEA]
comments: true
description: SW Expert Academy 1767
---

> [SW Expert Academy 1767](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV4suNtaXFEDFAUf&categoryId=AV4suNtaXFEDFAUf&categoryType=CODE&problemTitle=%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C&orderBy=FIRST_REG_DATETIME&selectCodeLang=ALL&select-1=&pageSize=10&pageIndex=1)

## Idea

### ğŸ¥šë³€ìˆ˜

- ArrayList<Point> cellList : coreì˜ ìœ„ì¹˜ê°€ ì €ì¥ë˜ì–´ìˆëŠ” ë¦¬ìŠ¤íŠ¸, ê°œìˆ˜ê°€ ê°€ë³€ì ì´ë¯€ë¡œ ArrayListë¡œ ì„ ì–¸
- int answer : ì „ì„ í•©ì˜ ìµœì†Œ ê¸¸ì´
- int count : ì„ íƒí•œ coreì˜ ìµœëŒ€ ê°¯ìˆ˜
  
### ğŸ³í’€ì´ ì „ëµ

DFS

1. ê¸°ì €ì¡°ê±´
   - í˜„ì¬ ê°€ë¦¬í‚¤ê³  ìˆëŠ” ê°’ curê°€ cellListê°œìˆ˜ë‘ ê°™ì•„ì§€ë©´ ì¢…ë£Œ
   - ì—°ê²°í•œ core ê°¯ìˆ˜ì¸ cntê°€ ì „ì—­ë³€ìˆ˜ countë³´ë‹¤ í° ê²½ìš° answerê°’ ê°±ì‹ , ê°’ì´ ê°™ë‹¤ë©´ ë” ì‘ì€ ê°’ìœ¼ë¡œ ê°±ì‹ 
2. ìœ ë„ì¡°ê±´
   - ê°€ì¥ìë¦¬ì— ìœ„ì¹˜í•œ ê²½ìš° ë°”ë¡œ ë‹¤ìŒ DFSë¡œ ë„˜ì–´ê°
   - ê·¸ë ‡ì§€ ì•Šì€ ê²½ìš°ì—ëŠ” 4ë°©í–¥ì„ íƒìƒ‰í•œë‹¤.
   - í•´ë‹¹ ë°©í–¥ìª½ìœ¼ë¡œ ì „ì„ ì„ ë†“ì„ ìˆ˜ ìˆìœ¼ë©´ ì „ì„ ì„ ë†“ì•„ì£¼ê³ , ë‹¤ìŒ DFSë¡œ ë„˜ì–´ê°.
   - ì „ì„ ì„ ë†“ì„ ìˆ˜ ì—†ìœ¼ë©´ ì„ íƒí•˜ì§€ ì•Šê³  ë‹¤ìŒ DFSë¡œ ë„˜ì–´ê°.
   - ê·¸ í›„ í•´ë‹¹ forë¬¸ ì•ˆì—ì„œ ì „ì„ ì„ ì›ìƒë³µêµ¬ ì‹œí‚¨ë‹¤. 
  
&nbsp;  
&nbsp;

<details>
<summary>code</summary>
<div markdown="1">

```java

import java.awt.Point;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.StringTokenizer;

public class Solution {
	
	private static int N, count, answer;
	private static int[][] dir = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} };
	
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = null;
		
		int T = Integer.parseInt(br.readLine());
		for (int test_case = 1; test_case <= T; test_case++)
		{
			count = 0;	// ì—°ê²°ëœ ì½”ì–´ ê°¯ìˆ˜
			answer = 0;	// ì „ì„  ê¸¸ì´
			N = Integer.parseInt(br.readLine());
			int[][] cell = new int[N][N];
			ArrayList<Point> cellList = new ArrayList<Point>();	
			
			for(int r=0; r<N; r++) {
				st = new StringTokenizer(br.readLine(), " ");
				for(int c=0; c<N; c++) {
					cell[r][c] = Integer.parseInt(st.nextToken());
					if(cell[r][c] == 1)	{
						cellList.add(new Point(r, c));
					}
				}
			}
			
			DFS(cellList, 0, 0, new int[cellList.size()], new boolean[N][N]);
			
			System.out.println("#" + test_case + " " + answer);
		}
	}

	private static void DFS(ArrayList<Point> cellList, int cur, int cnt, int[] line, boolean[][] map) {
		// ê¸°ì €ì¡°ê±´
		if(cur == cellList.size()) {
			
			if(cnt > count) {	// ìµœëŒ€í•œ ë§ì€ ì½”ì–´ë¥¼ ì—°ê²°í•´ì•¼ í•¨ 
				int sum = 0;
				for(int i=0; i<line.length; i++) {
					sum += line[i];
				}
				answer = sum;
				count = cnt;
			}
			else if(cnt == count) {
				int sum = 0;
				for(int i=0; i<line.length; i++) {
					sum += line[i];
				}
				answer = Math.min(answer, sum);
			}
			return;
		}
		
		// ìœ ë„ì¡°ê±´
		Point now = cellList.get(cur);
		map[now.x][now.y] = true;
		
		if(now.x == 0 || now.y == 0 || now.x == N-1 || now.y == N-1) {	// ê°€ì¥ìë¦¬ì— ìˆë‹¤ë©´ ë°”ë¡œ ì—°ê²°
			line[cur] = 0;
			DFS(cellList, cur+1, cnt+1, line, map);
			return;
		}
		
		for(int k=0; k<4; k++) { // ê°€ì¥ìë¦¬ì— ìˆì§€ ì•Šë‹¤ë©´ 4ë°© íƒìƒ‰
			int len = canConnect(now.x, now.y, k, map);
			
			if(len != -1) {
				Connect(now.x, now.y, k, map, true);	// mapì— true í‘œì‹œ
				line[cur] = len;
				DFS(cellList, cur+1, cnt+1, line, map);	// ë‹¤ìŒ íƒìƒ‰ìœ¼ë¡œ ë„˜ì–´ê°
				Connect(now.x, now.y, k, map, false);	// map ì›ìƒ ë³µêµ¬
			}
			else {
				line[cur] = 0;
				DFS(cellList, cur+1, cnt, line, map);
			}
		}
	}

	private static void Connect(int r, int c, int k, boolean[][] map, boolean data) {
		int nr = r;
		int nc = c;
		
		while(true) {
			nr += dir[k][0];
			nc += dir[k][1];
			
			if(nr < 0 || nr >= N || nc < 0 || nc >= N) {
				break;
			}
			
			map[nr][nc] = data;
		}
	}

	// r, c ê¸°ì¤€ìœ¼ë¡œ k ë°©í–¥ìœ¼ë¡œ ì­ˆìš± ì—°ê²°í•  ìˆ˜ ìˆë‹¤ë©´ ê¸¸ì´ë¥¼ ë°˜í™˜í•˜ê³ , ì•„ë‹ˆë©´ -1 ë°˜í™˜
	private static int canConnect(int r, int c, int k, boolean[][] map) {
		
		int nr = r;
		int nc = c;
		int sum = 0;
		
		while(true) {
			nr += dir[k][0];
			nc += dir[k][1];
			
			if(nr < 0 || nr >= N || nc < 0 || nc >= N) {
				break;
			}
			
			if(map[nr][nc]) {
				return -1;
			}
			
			sum++;
		}
		return sum;
	}
}

```

</div>
</details>

&nbsp;  
&nbsp;

## Review

1ì‹œê°„ 30ë¶„ë§Œì— í†µê³¼...!

whileë¬¸ì˜ ì¡°ê±´ë¬¸ì´ë‘ DFS ì¬ê·€ ìœ„ì¹˜ë¥¼ ì˜ëª» ì„¤ì •í•´ì£¼ì–´ì„œ ë¬´í•œ ë£¨í”„ë¥¼ ëŒì•˜ëŠ”ë° ê·¸ê±¸ ì¡ì•„ë‚´ëŠë¼ ì˜¤ë˜ ê±¸ë ¸ë‹¤.      
ë§¨ì²˜ìŒì— DFSë¡œ ì ‘ê·¼í•˜ìê³  ìƒê°í•œ ê²ƒì€ ì˜í•œë“¯...!

&nbsp;  
&nbsp;
