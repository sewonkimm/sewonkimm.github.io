---
layout: post
title: ë°±ì¤€ 15683:ê°ì‹œ
date: 2020-12-08 22:33:00
author: 'SeWonKim'
categories: [CS, Algorithm]
tags: [ì•Œê³ ë¦¬ì¦˜, ë°±ì¤€, BOJ]
comments: true
description: Baekjoon 15683
---

> [Baekjoon 15683](https://www.acmicpc.net/problem/15683)

## Idea

### ğŸ¥šë³€ìˆ˜

- int N : ì‚¬ë¬´ì‹¤ì˜ ì„¸ë¡œ í¬ê¸°
- int M : ì‚¬ë¬´ì‹¤ì˜ ê°€ë¡œ í¬ê¸°
- int[N][m] office : ì‚¬ë¬´ì‹¤ (1~5ëŠ” CCTV, 6ì€ ë²½)
- class CCTV : { int n, int m, int dir(cctv ì¢…ë¥˜) }
- ArrayList<CCTV> cctvList : CCTV ë¦¬ìŠ¤íŠ¸
- int[4][2] dir : CCTVê°€ ê°ì‹œí•  ìˆ˜ ìˆëŠ” ë°©í–¥ { {-1,0}, {0,-1}, {1, 0}, {0,1} }

### ğŸ³í’€ì´ ì „ëµ

`DFS`

1. office ì…ë ¥ë°›ì„ ë•Œ cctvList ê°™ì´ ìƒì„±
2. DFS íƒìƒ‰ ì‹œì‘
3. ë°©í–¥ëŒ€ë¡œ ë²½/ì‚¬ë¬´ì‹¤ ë²”ìœ„ ëê¹Œì§€ ì˜ì—­ í‘œì‹œ í›„ DFS ì¬ê·€

```
DFS (count) {
    // ê¸°ì €ì¡°ê±´
    if(count == cctvList.length) {
        // ì‚¬ê°ì§€ëŒ€ ë„“ì´ ê°±ì‹ 
    }

    // í˜¸ì¶œë¶€
    cctvList[count].dir ì— ë”°ë¼ ë‚˜ëˆ”
    if (dir == 1)
    else if(dir == 2)
    else if(dir == 3)
    else if(dir == 4)
}
```

í˜¸ì¶œë¶€ì˜ ê° if ë¬¸ ë‚´ë¶€ì—ì„œ whileë¬¸ìœ¼ë¡œ _ë²”ìœ„ì•ˆì— ìˆê³  && ë²½ì„ ë§Œë‚˜ê¸° ì „ê¹Œì§€_ ì˜ì—­ í‘œì‹œ í›„ DFS(count+1) í˜¸ì¶œ

&nbsp;  
&nbsp;

<details>
<summary>code</summary>
<div markdown="1">

```java
public class Main {

	public static class CCTV {
		int n, m, dir;

		public CCTV(int n, int m, int dir) {
			this.n = n;
			this.m = m;
			this.dir = dir;
		}
	}

	static int N, M, answer;
	static int[][] office;
	static ArrayList<CCTV> cctvList;
	static int[][] dir = { {-1,0}, {0,-1}, {1, 0}, {0,1} };	// ìƒ ì¢Œ í•˜ ìš°
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine(), " ");

		N = Integer.parseInt(st.nextToken());
		M = Integer.parseInt(st.nextToken());
		office = new int[N][M];
		cctvList = new ArrayList<CCTV>();

		for (int i = 0; i < N; i++) {
			st = new StringTokenizer(br.readLine(), " ");
			for (int j = 0; j < M; j++) {
				office[i][j] = Integer.parseInt(st.nextToken());
				if(office[i][j] >= 1 && office[i][j] <= 5) {
					cctvList.add(new CCTV(i, j, office[i][j]));
				}
			}
		}

		answer = Integer.MAX_VALUE;
		boolean[][] check = new boolean[N][M];
		dfs(0, check);

		System.out.println(answer);
	}

	private static void dfs(int count, boolean[][] check) {

		if(count == cctvList.size()) {
			answer = Math.min(answer, getRoom(check));
			return;
		}

		CCTV cctv = cctvList.get(count);
		boolean[][] tmpCheck = new boolean[N][M];
		copy(tmpCheck, check);
		switch(cctv.dir){
			case 1 :
				for (int k = 0; k < 4; k++) {
					int nn = cctv.n + dir[k][0];
					int nm = cctv.m + dir[k][1];
					while(nn>=0 && nn<N && nm>=0 && nm<M && office[nn][nm] != 6) {
						tmpCheck[nn][nm] = true;
						nn += dir[k][0];
						nm += dir[k][1];
					}
					dfs(count+1, tmpCheck);
					copy(tmpCheck, check);
				}
				break;
			case 2 :
				for (int k = 0; k < 2; k++) {
					int nn, nm;
					for (int l = 0; l <=2 ; l+=2) {
						nn = cctv.n + dir[k+l][0];
						nm = cctv.m + dir[k+l][1];
						while(nn>=0 && nn<N && nm>=0 && nm<M && office[nn][nm] != 6) {
							tmpCheck[nn][nm] = true;
							nn += dir[k+l][0];
							nm += dir[k+l][1];
						}
					}
					dfs(count+1, tmpCheck);
					copy(tmpCheck, check);
				}
				break;
			case 3 :
				for (int k = 0; k <4; k++) {
					int nn, nm;
					for (int l = 0; l < 2; l++) {
						nn = cctv.n + dir[(k+l)%4][0];
						nm = cctv.m + dir[(k+l)%4][1];
						while(nn>=0 && nn<N && nm>=0 && nm<M && office[nn][nm] != 6) {
							tmpCheck[nn][nm] = true;
							nn += dir[(k+l)%4][0];
							nm += dir[(k+l)%4][1];
						}
					}

					dfs(count+1, tmpCheck);
					copy(tmpCheck, check);
				}
				break;
			case 4 :
				for (int k = 0; k < 4; k++) {

					int nn, nm;
					for (int l = 0; l < 3; l++) {
						nn = cctv.n + dir[(k+l)%4][0];
						nm = cctv.m + dir[(k+l)%4][1];
						while(nn>=0 && nn<N && nm>=0 && nm<M && office[nn][nm] != 6) {
							tmpCheck[nn][nm] = true;
							nn += dir[(k+l)%4][0];
							nm += dir[(k+l)%4][1];
						}

					}
					dfs(count+1, tmpCheck);
					copy(tmpCheck, check);
				}
				break;
			case 5 :
				for (int k = 0; k < 4; k++) {
					int nn = cctv.n + dir[k][0];
					int nm = cctv.m + dir[k][1];

					while(nn>=0 && nn<N && nm>=0 && nm<M && office[nn][nm] != 6) {
						tmpCheck[nn][nm] = true;
						nn += dir[k][0];
						nm += dir[k][1];
					}
				}
				dfs(count+1, tmpCheck);
				break;
			default : break;
		}
	}

	private static void copy(boolean[][] tmpCheck, boolean[][] check) {
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < M; j++) {
				tmpCheck[i][j] = check[i][j];
			}
		}
	}

	private static int getRoom(boolean[][] check) {
		int count = 0;
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < M; j++) {
				if(check[i][j] == false && office[i][j] == 0)	count++;
			}
		}
		return count;
	}

}

```

</div>
</details>

&nbsp;  
&nbsp;

## Review

ì–´í›„... ë°©í–¥ëŒ€ë¡œ 90ë„ì”© íšŒì „í•´ê°€ë©´ì„œ í•´ì£¼ëŠ”ê±° í•˜ë“œì½”ë”©í•˜ëŠë¼ê³ ... @,@... ì½”ë“œê°€ ë„ˆë¬´ ê¸¸ì–´ì§„ ê²ƒ ê°™ë‹¤. ë” ì¤„ì¼ ìˆ˜ ìˆëŠ” ë°©ë²•ì´ ì—†ì„ê¹Œ...?
&nbsp;  
&nbsp;
