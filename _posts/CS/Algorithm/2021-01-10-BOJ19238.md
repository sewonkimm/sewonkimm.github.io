---
layout: post
title: ë°±ì¤€ 19238:ìŠ¤íƒ€íŠ¸ íƒì‹œ
date: 2021-01-10 15:05:00
author: 'SeWonKim'
categories: [CS, Algorithm]
tags: [ì•Œê³ ë¦¬ì¦˜, ë°±ì¤€, BOJ]
comments: true
description: Baekjoon 19238
---

> [Baekjoon 19238](https://www.acmicpc.net/problem/19238)

## Idea

### ğŸ¥šë³€ìˆ˜

- int N : mapì˜ í¬ê¸°
- int M : ìŠ¹ê° ìˆ˜
- int count : ì§€ê¸ˆê¹Œì§€ íƒœìš´ ìŠ¹ê°ì˜ ìˆ˜
- int fuel : ì´ˆê¸° ì—°ë£Œì˜ ì–‘
- int[N][N] map 
- int[4][2] dir : 4ë°©í–¥ íƒìƒ‰ì„ ìœ„í•œ delta
- int[N][N] dis : ìµœë‹¨ ê±°ë¦¬ íƒìƒ‰ì„ ìœ„í•œ 2ì°¨ì› ë°°ì—´
- class Customer : int distance, startR, startC, endR, endC
  
### ğŸ³í’€ì´ ì „ëµ

1. íƒì‹œì—ì„œ ìµœë‹¨ ê±°ë¦¬ê°€ ê°€ì¥ ì§§ì€ ìŠ¹ê°ì„ ê³ ë¦„
   - priorty queue ë¥¼ ì‚¬ìš©í•´ì„œ íƒì‹œì—ì„œ ì¶œë°œì§€ê¹Œì§€ì˜ ê±°ë¦¬, í–‰, ì—´ ìˆœì„œë¡œ ì •ë ¬ 
   - í˜„ì¬ ìœ„ì¹˜ì—ì„œ ìŠ¹ê°ì—ê²Œ ê°ˆ ìˆ˜ ì—†ìœ¼ë©´ -1 ì¶œë ¥. ê²Œì„ ì¢…ë£Œ.
   - ì´ë™ ê°€ëŠ¥í•˜ë©´ fuelì—ì„œ ê±°ë¦¬ë¥¼ ë¹¼ê³  2ë²ˆìœ¼ë¡œ ë„˜ì–´ê°
2. ê·¸ ìŠ¹ê°ì˜ ìœ„ì¹˜ë¡œë¶€í„° ëª©ì ì§€ê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬ë¥¼ ê³„ì‚°
   - ì—°ë£Œê°€ ë¶€ì¡±í•˜ë©´ -1 ì¶œë ¥. ê²Œì„ ì¢…ë£Œ.
   - ì´ë™ ê°€ëŠ¥í•˜ë©´ ì´ë™ í›„ ì†Œëª¨í•œ ì—°ë£Œì˜ 2ë°° ì–‘ìœ¼ë¡œ ì¶©ì „ í›„ íƒì‹œì˜ ìœ„ì¹˜ ë³€ê²½
3. íƒœìš´ ìŠ¹ê° count, 1ë²ˆë¶€í„° ë°˜ë³µ

ğŸ”¥ í•µì‹¬ : **ìµœë‹¨ ê±°ë¦¬ ì´ë™** ğŸ”¥ => BFS 

&nbsp;  
&nbsp;


<details>
<summary>code - ì‹œê°„ì´ˆê³¼</summary>
<div markdown="1">

- íƒœìš¸ ìŠ¹ê°ì„ ì°¾ëŠ” ê²ƒê³¼ ì¶œë°œì§€ì—ì„œ ëª©ì ì§€ë¡œ ì´ë™í•  ë•Œ ë™ì¼í•œ BFSë¥¼ ì‚¬ìš©í•œê²Œ ë¬¸ì œê°€ ë˜ëŠ” ê±´ê°€...?
  
```java
import java.io.*;
import java.util.*;

public class BOJ19238_ìŠ¤íƒ€íŠ¸íƒì‹œ {
    public static class Customer implements Comparable<Customer> {
        int distance, startR, startC, endR, endC;

        public Customer(int distance, int startR, int startC, int endR, int endC) {
            this.distance = distance;
            this.startR = startR;
            this.startC = startC;
            this.endR = endR;
            this.endC = endC;
        }

        @Override
        public int compareTo(Customer o) {
            if(this.distance == o.distance) {
                if(this.startR == o.startR) return this.startC - o.startC;
                return this.startR - o.startR;
            }
            return this.distance - o.distance;
        }
    }

    static int N;
    static int[][] map;
    static int[][] dir = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} };
    public static void main(String[] args) throws Exception{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine(), " ");
        N = Integer.parseInt(st.nextToken());
        int M = Integer.parseInt(st.nextToken());
        int fuel = Integer.parseInt(st.nextToken());

        // intput
        map = new int[N][N];
        for (int i = 0; i < N; i++) {
            st = new StringTokenizer(br.readLine(), " ");
            for (int j = 0; j < N; j++) {
                map[i][j] = Integer.parseInt(st.nextToken());
            }
        }

        st = new StringTokenizer(br.readLine(), " ");
        int taxiR = Integer.parseInt(st.nextToken()) - 1;
        int taxiC = Integer.parseInt(st.nextToken()) - 1;

        PriorityQueue<Customer> customers = new PriorityQueue<Customer>();
        for (int i = 0; i < M; i++) {
            st = new StringTokenizer(br.readLine(), " ");
            int startR = Integer.parseInt(st.nextToken()) - 1;
            int startC = Integer.parseInt(st.nextToken()) - 1;
            int endR = Integer.parseInt(st.nextToken()) - 1;
            int endC = Integer.parseInt(st.nextToken()) - 1;

            customers.add(new Customer(getDistance(taxiR, taxiC, startR, startC), startR, startC, endR, endC));
        }

        while(!customers.isEmpty()) {
            // íƒì‹œì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ ìŠ¹ê° ì„ íƒ
            Customer customer = customers.poll();

            int distance = getDistance(customer.startR, customer.startC, customer.endR, customer.endC);

            if(fuel < customer.distance || fuel-customer.distance < distance) {
                System.out.println(-1);
                return;
            }

            fuel = fuel - customer.distance + distance;
            taxiR = customer.endR;
            taxiC = customer.endC;

            PriorityQueue<Customer> tmp = new PriorityQueue<>();
            while(!customers.isEmpty()) {
                Customer c = customers.poll();
                tmp.add(new Customer(getDistance(taxiR, taxiC, c.startR, c.startC), c.startR, c.startC, c.endR, c.endC));
            }
            customers = tmp;
        }
        System.out.println(fuel);
    }

    private static int getDistance(int startR, int startC, int endR, int endC) {
        int[][] distance = new int[N][N];
        for (int i = 0; i < N; i++) {
            Arrays.fill(distance[i], Integer.MAX_VALUE);
        }
        distance[startR][startC] = 0;
        Queue<int[]> q = new LinkedList<int[]>();
        q.add(new int[] {startR, startC});

        while(!q.isEmpty()) {
            int[] now = q.poll();

            for (int k = 0; k < 4; k++) {
                int nextR = now[0] + dir[k][0];
                int nextC = now[1] + dir[k][1];

                if(nextR >= 0 && nextR < N && nextC >= 0 &&nextC < N && map[nextR][nextC] != 1) {
                    if(distance[nextR][nextC] > distance[now[0]][now[1]]+1) {
                        distance[nextR][nextC] = distance[now[0]][now[1]]+1;
                        q.add(new int[] {nextR, nextC});
                    }
                }
            }
        }
        return distance[endR][endC];
    }
}

```

</div>
</details>


<details>
<summary>code</summary>
<div markdown="1">

1. íƒœìš¸ ìŠ¹ê°ì„ ì°¾ìŒ 
2. íƒœìš¸ ìŠ¹ê°ì„ ì°¾ì§€ ëª»í•œ ê²½ìš° ğŸ‘‰ case1. ëª¨ë“  ìŠ¹ê°ì„ ë‹¤ íƒœìš´ ê²½ìš°, case2. ìŠ¹ê°ì—ê²Œ ê°ˆ ìˆ˜ ì—†ëŠ” ê²½ìš°
3. ìŠ¹ê°ì„ ëª©ì ì§€ê¹Œì§€ ë°ë ¤ë‹¤ì£¼ì§€ ëª»í•˜ëŠ” ê²½ìš° 
   1. ìŠ¹ê°ì„ íƒœìš°ëŸ¬ ê°€ë‹¤ê°€ ì—°ë£Œê°€ ë–¨ì–´ì§
   2. ì¶œë°œì§€ì—ì„œ ëª©ì ì§€ê¹Œì§€ ê°€ë‹¤ê°€ ì—°ë£Œê°€ ë–¨ì–´ì§
   3. ì¶œë°œì§€ì—ì„œ ëª©ì ì§€ê¹Œì§€ ê°ˆ ìˆ˜ê°€ ì—†ìŒ


```java
import java.io.*;
import java.util.*;

public class BOJ19238_ìŠ¤íƒ€íŠ¸íƒì‹œ {
    public static class Customer implements Comparable<Customer> {
        int distance, startR, startC, endR, endC;

        public Customer(int startR, int startC, int endR, int endC) {
            this.startR = startR;
            this.startC = startC;
            this.endR = endR;
            this.endC = endC;
        }

        public Customer(int distance, int startR, int startC) {
            this.distance = distance;
            this.startR = startR;
            this.startC = startC;
        }

        @Override
        public int compareTo(Customer o) {
            if(this.distance == o.distance) {
                if (this.startR == o.startR) return this.startC - o.startC;
                return this.startR - o.startR;
            }
            return this.distance - o.distance;
        }
    }

    static int N;
    static int[][] map;
    static int[][] dir = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} };
    public static void main(String[] args) throws Exception{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine(), " ");
        N = Integer.parseInt(st.nextToken());
        int M = Integer.parseInt(st.nextToken());
        int fuel = Integer.parseInt(st.nextToken());
        int customerCount = 0;

        // intput
        map = new int[N][N];
        for (int i = 0; i < N; i++) {
            st = new StringTokenizer(br.readLine(), " ");
            for (int j = 0; j < N; j++) {
                map[i][j] = Integer.parseInt(st.nextToken());
            }
        }

        st = new StringTokenizer(br.readLine(), " ");
        int taxiR = Integer.parseInt(st.nextToken()) - 1;
        int taxiC = Integer.parseInt(st.nextToken()) - 1;

        ArrayList<Customer> customers = new ArrayList<Customer>();
        for (int i = 0; i < M; i++) {
            st = new StringTokenizer(br.readLine(), " ");
            int startR = Integer.parseInt(st.nextToken()) - 1;
            int startC = Integer.parseInt(st.nextToken()) - 1;
            int endR = Integer.parseInt(st.nextToken()) - 1;
            int endC = Integer.parseInt(st.nextToken()) - 1;
            map[startR][startC] = 2;

            customers.add(new Customer(startR, startC, endR, endC));
        }

        while(true) {
            int customerIndex = findCustomer(taxiR, taxiC, customers);
            if(customerIndex == -1) {   // íƒœìš¸ ìŠ¹ê°ì„ ëª» ì°¾ìŒ
                if(customerCount < M)   fuel = -1;
                break;
            }
            // ìŠ¹ê°ì„ ëª©ì ì§€ê¹Œì§€ ë°ë ¤ë‹¤ ì¤Œ
            int startR = customers.get(customerIndex).startR;
            int startC = customers.get(customerIndex).startC;
            int endR = customers.get(customerIndex).endR;
            int endC = customers.get(customerIndex).endC;
            int distance = getDistance(startR, startC, endR, endC);

            // íƒì‹œê°€ ìŠ¹ê°ì„ íƒœìš°ëŸ¬ ëª»ê°€ê±°ë‚˜, ì¶œë°œì§€ì—ì„œ ëª©ì ì§€ê¹Œì§€ ê°ˆ ìˆ˜ ì—†ëŠ” ê²½ìš°
            if(fuel < customers.get(customerIndex).distance || distance == -1 || fuel-customers.get(customerIndex).distance < distance) {
                fuel = -1;
                break;
            }

            fuel = fuel - customers.get(customerIndex).distance + distance;
            taxiR = endR;
            taxiC = endC;
            customerCount++;
        }

        System.out.println(fuel);
    }

    private static int findCustomer(int R, int C, ArrayList<Customer> customers) {
        PriorityQueue<Customer> pq = new PriorityQueue<Customer>();
        boolean[][] visit = new boolean[N][N];
        pq.add(new Customer(0, R, C));
        visit[R][C] = true;

        int ret = -1;
        while(!pq.isEmpty()) {
            Customer customer = pq.poll();

            if(map[customer.startR][customer.startC] == 2) {
                for (int i = 0; i < customers.size(); i++) {
                    if(customers.get(i).startR == customer.startR && customers.get(i).startC == customer.startC) {
                        ret = i;
                        customers.get(i).distance = customer.distance;
                        map[customer.startR][customer.startC] = 0;
                    }
                }
                break;
            }

            for (int k = 0; k < 4; k++) {
                int nextR = customer.startR + dir[k][0];
                int nextC = customer.startC + dir[k][1];

                if(nextR >= 0 && nextR < N && nextC >= 0 &&nextC < N && map[nextR][nextC] != 1 && !visit[nextR][nextC]) {
                    visit[nextR][nextC] = true;
                    pq.add(new Customer(customer.distance+1, nextR, nextC));
                }

            }
        }
        return ret;
    }

    private static int getDistance(int startR, int startC, int endR, int endC) {
        int[][] distance = new int[N][N];
        for (int i = 0; i < N; i++) {
            Arrays.fill(distance[i], Integer.MAX_VALUE);
        }
        distance[startR][startC] = 0;
        Queue<int[]> q = new LinkedList<int[]>();
        q.add(new int[] {startR, startC});

        while(!q.isEmpty()) {
            int[] now = q.poll();

            for (int k = 0; k < 4; k++) {
                int nextR = now[0] + dir[k][0];
                int nextC = now[1] + dir[k][1];

                if(nextR == endR && nextC == endC) {
                    if(distance[nextR][nextC] > distance[now[0]][now[1]]+1) return distance[now[0]][now[1]]+1;
                    return distance[nextR][nextC];
                }

                if(nextR >= 0 && nextR < N && nextC >= 0 &&nextC < N && map[nextR][nextC] != 1) {
                    if(distance[nextR][nextC] > distance[now[0]][now[1]]+1) {
                        distance[nextR][nextC] = distance[now[0]][now[1]]+1;
                        q.add(new int[] {nextR, nextC});
                    }
                }
            }
        }
        return -1;
    }
}

```

</div>
</details>

&nbsp;  
&nbsp;

## Review

BFSë¥¼ í™œìš©í•˜ëŠ” êµ¬í˜„

&nbsp;  
&nbsp;
