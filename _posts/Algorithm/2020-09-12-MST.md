---
layout: post
title: ìµœì†Œì‹ ì¥íŠ¸ë¦¬ MST ì •ë¦¬
date: 2020-09-12 22:39:00
author: "SeWonKim"
categories: [CS, Algorithm]
tags: [ì•Œê³ ë¦¬ì¦˜, Baekjoon, MST, kruskal, prime, dijkstra]
fullview: false
comments: true
description: Kruskal, Prime, Dijkstra
---

`ê°„.ì .í¬! ê°„.ë§Œ.í”„!`

## ğŸ’šKruskal - union-find ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ êµ¬í˜„

```java
import java.io.*;
import java.util.*;

/*
3 3
1 3 3
1 2 1
2 3 2
=>3
*/

public class Kruskal {

	static class Edge implements Comparable<Edge> {
        int s,e,w;

        public Edge(int s, int e, int w){
            this.s = s;
            this.e = e;
            this.w = w;
        }

		@Override
		public int compareTo(Edge o) {
			return this.w - o.w;
		}
    }

    // ëŒ€í‘œì ë°°ì—´ ë§Œë“¤ê¸°
    private static void makeSet(){
        for(int i=1; i<=V; i++){
            parents[i] = i;
        }
    }

    // ì •ì ì˜ ëŒ€í‘œ ì°¾ê¸°
    private static int find(int x){
        if(parents[x] == x) return x;
        return parents[x] = find(parents[x]);
    }

    // ì •ì ê³¼ ì •ì  ì—°ê²°í•´ì£¼ê¸°
    private static boolean union(int x, int y){
        int px = find(x);
        int py = find(y);

        if(px != py){
            parents[py] = px;
            return true;
        }
        return false;
    }

    static int[] parents;
    static int V, E;
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
        V = Integer.parseInt(st.nextToken());
        E = Integer.parseInt(st.nextToken());
        Edge[] edgeList = new Edge[E];
        
        for(int i=0; i<E; i++){
            st = new StringTokenizer(br.readLine());
            int x = Integer.parseInt(st.nextToken());
            int y = Integer.parseInt(st.nextToken());
            int w = Integer.parseInt(st.nextToken());
            edgeList[i] = new Edge(x, y, w);
        }

        parents = new int[V+1];
        makeSet();

        Arrays.sort(edgeList); // ê°„ì„  ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬

        int result = 0;
        int cnt = 0;
        for(Edge edge : edgeList){
            if(union(edge.s, edge.e)){
                result += edge.w;
                if(++cnt == V-1){   // V-1ê°œ ì—°ê²°í–ˆìœ¼ë©´ ì‚¬ì´í´ì´ ìƒê¹€
                    break;
                }
            }
        }

        System.out.println(result);
	}

}
```
&nbsp;
&nbsp;

---

## ğŸ’›Prime - ë°°ì—´ë¡œ êµ¬í˜„

```java
import java.io.*;
import java.io.*;

/*
7
0 32 31 0 0 60 51
32 0 21 0 0 0 0
31 21 0 0 46 0 25
0 0 0 0 34 18 0
0 0 46 34 0 40 51
60 0 0 18 40 0 0
51 0 25 0 51 0 0
==>175
*/

public class Prime {

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(br.readLine().trim());
        int[][] input = new int[N][N];
        int[] minEdge = new int[N];
        boolean[] visited = new boolean[N];

        for(int i=0; i<N; i++){
            StringTokenizer st = new StringTokenizer(br.readLine());
            for(int j=0; j<N; j++){
                input[i][j] = Integer.parseInt(st.nextToken());
            }
            minEdge[i] = Integer.MAX_VALUE;
        }

        int minVertex = 0;  // ì‹œì‘ ì •ì ì„ 0ìœ¼ë¡œ í•œë‹¤.
        int min = 0;
        int result = 0;
        minEdge[0] = 0;     // ì‹œì‘ì  ìµœì†Œ ê°„ì„ ë¹„ìš©ì€ 0

        for(int c=0; c<N; c++){
            
            min = Integer.MAX_VALUE;    // ë°©ë¬¸í•  ì •ì  ì„ íƒí•˜ê¸°
            minVertex = 0;
            for(int i = 0; i<N; i++){
                if(!visited[i] && min > minEdge[i]){
                    min = minEdge[i];
                    minVertex = i;
                }
            }

            result += min;  // ì‹ ì¥íŠ¸ë¦¬ ë¹„ìš© ëˆ„ì 
            visited[minVertex] = true;

            // ì„ íƒëœ ì •ì ê³¼ ì—°ê²°ë˜ì–´ìˆëŠ” ë‹¤ë¥¸ ì •ì ìœ¼ë¡œì˜ ë¹„ìš© ê³„ì‚°í•´ì„œ ìµœì†Ÿê°’ ê°±ì‹ (ë°°ì—´ ì—…ë°ì´íŠ¸)
            for(int i=0; i<N; i++){
                // ì‹ ì¥íŠ¸ë¦¬ì— í¬í•¨ë˜ì§€ ì•Šì€
                // ì¸ì ‘í•œ ì •ì ì¸ ê²½ìš°
                // ë¹„ìš©ì„ ë¹„êµí•´ì„œ ìµœì†Œë¹„ìš© ê°±ì‹ 
                if(!visited[i] && input[minVertex][i] != 0 &&minEdge[i] > input[minVertex][i]){
                    minEdge[i] = input[minVertex][i];
                }
            }
        }
        
        System.out.println(result);
	}
}
```
&nbsp;
&nbsp;

## ğŸ’›Prime - Priority Queueë¡œ êµ¬í˜„

ê·¸ëƒ¥ Prime ê³¼ ë‹¤ë¥¸ì 

1. Vertex class ìƒì„± - Comparable interface êµ¬í˜„í•˜ê¸°
2. MST í¬í•¨í•œ ì •ì ì˜ ê°¯ìˆ˜ë¥¼ ì„¸ëŠ” cntë¡œ whileë¬¸ íƒˆì¶œ

```java
import java.io.*;
import java.util.*;

/*
7
0 32 31 0 0 60 51
32 0 21 0 0 0 0
31 21 0 0 46 0 25
0 0 0 0 34 18 0
0 0 46 34 0 40 51
60 0 0 18 40 0 0
51 0 25 0 51 0 0
==>175
*/

public class Prime_PriorityQueue {

	static public class Vertex implements Comparable<Vertex> {
		int no;
		int weight;

		public Vertex(int no, int weight) {
			this.no = no;
			this.weight = weight;
		}

		@Override
		public int compareTo(Vertex o) {
			return this.weight - o.weight;
		}
	}

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int N = Integer.parseInt(br.readLine().trim());
		int[][] input = new int[N][N];
		int[] minEdge = new int[N];
		boolean[] visited = new boolean[N];
		PriorityQueue<Vertex> pq = new PriorityQueue<Vertex>();

		for (int i = 0; i < N; i++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			for (int j = 0; j < N; j++) {
				input[i][j] = Integer.parseInt(st.nextToken());
			}
			minEdge[i] = Integer.MAX_VALUE;
		}

		int vertexCnt = 0;
		int result = 0;
		minEdge[0] = 0; // ì‹œì‘ì  ìµœì†Œ ê°„ì„ ë¹„ìš©ì€ 0
		pq.offer(new Vertex(0, 0));

		while (!pq.isEmpty()) {
			Vertex minVertex = pq.poll();
			if (visited[minVertex.no])
				continue;

			result += minVertex.weight; // ì‹ ì¥íŠ¸ë¦¬ ë¹„ìš© ëˆ„ì 
			visited[minVertex.no] = true;
			if (++vertexCnt == N)
				break;

			// ì„ íƒëœ ì •ì ê³¼ ì—°ê²°ë˜ì–´ìˆëŠ” ë‹¤ë¥¸ ì •ì ìœ¼ë¡œì˜ ë¹„ìš© ê³„ì‚°í•´ì„œ ìµœì†Ÿê°’ ê°±ì‹ (ë°°ì—´ ì—…ë°ì´íŠ¸)
			for (int i = 0; i < N; i++) {
				// ì‹ ì¥íŠ¸ë¦¬ì— í¬í•¨ë˜ì§€ ì•Šì€
				// ì¸ì ‘í•œ ì •ì ì¸ ê²½ìš°
				// ë¹„ìš©ì„ ë¹„êµí•´ì„œ ìµœì†Œë¹„ìš© ê°±ì‹ 
				if (!visited[i] && input[minVertex.no][i] != 0 && minEdge[i] > input[minVertex.no][i]) {
					minEdge[i] = input[minVertex.no][i];
					pq.offer(new Vertex(i, input[minVertex.no][i]));
				}
			}
		}

		System.out.println(result);
	}
}
```
&nbsp;
&nbsp;

---

## ğŸ’™Dijkstra - ë°°ì—´ë¡œ êµ¬í˜„

Prime ì•Œê³ ë¦¬ì¦˜ê³¼ ìœ ì‚¬

í•˜ë‚˜ì˜ `ì‹œì‘ì `ì—ì„œ `ë„ì°©ì `ê¹Œì§€ì˜ ìµœë‹¨ ê²½ë¡œ     
ìŒì˜ ê°€ì¤‘ì¹˜ê°€ ì—†ì„ ê²½ìš°ì—ë§Œ ì‚¬ìš© ê°€ëŠ¥(ìŒì˜ ê°€ì¤‘ì¹˜ê°€ ìˆì„ ê²½ìš° Bellman-Ford ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©)

```java
import java.io.*;
import java.util.*;

/*
5
0 2 2 5 9
2 0 3 4 8
2 3 0 7 6
5 4 7 0 5
9 8 6 5 0
output==> 8
*/
public class Dijkstra {

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int N = Integer.parseInt(br.readLine());
		int start = 0;
		int end = N-1;
		int[][] map = new int[N][N];
		int[] distance = new int[N];		// ì‹œì‘ì ì—ì„œ iê¹Œì§€ ê°€ëŠ” ìµœë‹¨ê²½ë¡œ ë¹„ìš©
		boolean[] visited = new boolean[N];
		
		for(int i=0; i<N; i++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			for(int j=0; j<N; j++) {
				map[i][j] = Integer.parseInt(st.nextToken());
			}
			distance[i] = Integer.MAX_VALUE;
		}
		
		distance[start] = 0;
		
		int min = 0, current = 0;
		
		for(int i=0; i<N; i++) {
			min = Integer.MAX_VALUE;
			
			// ë°©ë¬¸í•˜ì§€ ì•Šì€ ì •ì  ì¤‘, ì¶œë°œì§€ì—ì„œ ìì‹ ê¹Œì§€ ì˜¤ëŠ” ë¹„ìš©ì´ ìµœë‹¨ì¸ ì •ì ì„ ê³ ë ¤í•  ê²½ìœ ì§€ë¡œ ì„ íƒ
			for(int j=0; j<N; j++) {
				if(!visited[j] && min > distance[j]) {
					min = distance[j];
					current = j;
				}
			}
			
			visited[current] = true;	// ì •ì  ì„ íƒ
			
			if(current == end)	break;	// ë„ì°©ì§€

			// ì„ íƒí•œ ì •ì ì—ì„œ ê°ˆ ìˆ˜ ìˆëŠ” ëª¨ë“  ì •ì ìœ¼ë¡œì˜ ìµœì†Œë¹„ìš© ê°±ì‹ 
			for(int j=0; j<N; j++) {
				if(!visited[j] && map[current][j] != 0) {
					distance[j] = Math.min(distance[j], min+map[current][j]);
				}
			}
		}
		
		System.out.println(distance[end]);
	}
}
```
&nbsp;
&nbsp;


## ğŸ’™Dijkstra - Priority Queueë¡œ êµ¬í˜„

```java
import java.io.*;
import java.util.*;

/*
5
0 2 2 5 9
2 0 3 4 8
2 3 0 7 6
5 4 7 0 5
9 8 6 5 0
output==> 8

4 
0 94 53 16 
79 0 24 18 
91 80 0 98 
26 51 92 0
output==> 16
*/
public class Dijkstra_PriorityQueue {

	static public class current implements Comparable<current> {
		int no;
		int totalDistance;	// ì¶œë°œì§€ì—ì„œ ìì‹ ê¹Œì§€ ì˜¤ëŠ” ìµœë‹¨ê±°ë¦¬

		public current(int no, int totalDistance) {
			this.no = no;
			this.totalDistance = totalDistance;
		}

		@Override
		public int compareTo(current o) {
			return this.totalDistance - o.totalDistance;
		}
	}

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int N = Integer.parseInt(br.readLine());
		int start = 0;
		int end = N - 1;
		int[][] map = new int[N][N];
		int[] distance = new int[N]; // ì‹œì‘ì ì—ì„œ iê¹Œì§€ ê°€ëŠ” ìµœë‹¨ê²½ë¡œ ë¹„ìš©
		boolean[] visited = new boolean[N];
		PriorityQueue<current> pq = new PriorityQueue<current>();

		for (int i = 0; i < N; i++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			for (int j = 0; j < N; j++) {
				map[i][j] = Integer.parseInt(st.nextToken());
			}
			distance[i] = Integer.MAX_VALUE;
		}

		distance[start] = 0;
		pq.offer(new current(start, 0));

		while (!pq.isEmpty()) {
			current current = pq.poll();

			visited[current.no] = true; // ì •ì  ì„ íƒ

			if (current.no == end)
				break; // ë„ì°©ì§€

			// ì„ íƒí•œ ì •ì ì—ì„œ ê°ˆ ìˆ˜ ìˆëŠ” ëª¨ë“  ì •ì ìœ¼ë¡œì˜ ìµœì†Œë¹„ìš© ê°±ì‹ 
			for (int j = 0; j < N; j++) {
				if (!visited[j] && map[current.no][j] != 0) {
					distance[j] = Math.min(distance[j], current.totalDistance + map[current.no][j]);
					pq.offer(new current(j, distance[j]));
				}
			}
		}
		System.out.println(distance[end]);
	}

}

```
&nbsp;
&nbsp;

---

## ğŸ’œFloyd Warshall

```
for(int k = 0 ~ ì •ì  ìˆ˜) {		// ê²½ìœ ì§€
	for(int i = 0 ~ ì •ì  ìˆ˜){	// ì¶œë°œì§€
		for(int j= 0 ~ ì •ì  ìˆ˜) {	// ë„ì°©ì§€
			dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j])
		}
	}
}
```

&nbsp;
&nbsp;
